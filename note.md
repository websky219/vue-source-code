## javascript 从入门到进阶的知识点

### 浏览器加载原理

1. 浏览器一边下载 HTML 网页,一遍开始解析
2. 解析发现<script>暂停解析,网页渲染控制权交给 javascript 引擎
3. 如果<script>标签引用了外部脚本,就下载该脚本,否则直接执行
4. 执行完毕，控制权交换给渲染引擎,恢复往下解析 Html 网页

### CommonJs/AMD/UMD/ES6

1. common.js 规范加载模块是同步的
2. CommonJs 有一个重大的局限使得它不适用于浏览器环境
3. 浏览器端一般采用 AMD 规范(require)
4. CMD 专门用于浏览器端，模块加载是异步的，模块使用是才会加载(sea.js)
5. AMD 和 CMD 最大的区别是对**依赖模块的执行时机处理不同**，而不是加载的时机或者方式不同，二者皆为异步加载模块。
6. AMD 依赖前置，js 可以方便知道依赖模块是谁，立即加载
7. **两者都是异步加载，只是执行时机不一样。AMD 是依赖前置，提前执行，CMD 是依赖就近，延迟执行。**
8. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
9. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

### this 函数指向的场景

1. 作为构造函数被 new 调用
2. 作为对象的方法调用
3. 作为函数调用
4. 被 call,apply,bind 调用
5. 箭头函数中调用

---

1. this 绑定优先级 new 绑定>显示绑定>隐式绑定>默认绑定

### 说说对于 SSR 了解？有没有使用过

1.  是 vue 在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的 html 片段直接返回给客户端这个过程就叫做服务端渲染。

- 优点
  1.  更好的 SEO：因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面
  2.  更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间.
- 缺点
  1. 更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境;更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用 CPU 资源。

### 写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？

1.  key 是给每一个 vnode 的唯一 id,可以依靠 key,更准确, 更快的拿到 oldVnode 中对应的 vnode 节点。
2.  更准确：因为带 key 就不是就地复用了，在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确。
3.  更快：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快。
4.  vue 和 react 都是采用 diff 算法来对比新旧虚拟节点，从而更新节点。在 vue 的 diff 函数中
    在交叉对比中，当新节点跟旧节点头尾交叉对比没有结果时，会根据新节点的 key 去对比旧节点数组中的 key，从而找到相应旧节点（这里对应的是一个 key => index 的 map 映射）。如果没找到就认为是一个新增节点。而如果没有 key，那么就会采用遍历查找的方式去找到对应的旧节点。一种一个 map 映射，另一种是遍历查找。相比而言。map 映射的速度更快。
 ### Vue 的响应式原理中 Object.defineProperty 有什么缺陷？为什么在 Vue3.0 采用了 Proxy，抛弃了 Object.defineProperty？
 1. Object.defineProperty无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应
 2. Object.defineProperty只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。Proxy可以劫持整个对象，并返回一个新的对象。  
 3. Proxy不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。 

 ### css盒模型
   1. 基本概念：标准模型+IE模型
   2. 标准模型和IE模型区别
   3. css如何设置这两种模型
   4. js如何设置获取盒模型对应的宽和高 
   5. 实例题(根据盒模型解释边距重叠)
   6. BFC(边距重叠解决方案)
 ### Dom事件类
   1. 基本概念：Dom事件的级别
   2. Dom事件模型
   3. Dom事件流
   4. 描述Dom事件捕获的具体流程
   5. Event对象的常见应用
   6. 自定义事件  
  ### 浏览器渲染机制
     1. 什么是DOCTYPE及作用 
     2. 浏览器渲染过程
     3. 重排Reflow
  ### js运行机制
  ### 页面性能
  ### 错误监控 
  ### javascript垃圾回收机制
  * 垃圾回收机制在运行的时候会给存储内存中的所有的变量都加上标记，然后会去掉处在环境中的变量以及被环境中的变量引用的变量标记(b闭包)。而在此之后剩下的带有标记的变量被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后垃圾回收机制到下一个周期运行时，将释放这些变量的内存，回收它们所占用的空间。
  1. 标记清除

